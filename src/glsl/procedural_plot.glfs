#version 420

#define SHOW_GRID 0
#define SHOW_GRAPH 0

/*
The following interface is implemented in this shader:
//***** begin interface of procedural_plot.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
//***** end interface of procedural_plot.glfs ***********************************
*/

//***** begin interface of hallo_world.glfs ***********************************
vec4 test_color(vec4 color);
//***** end interface of hallo_world.glfs ***********************************

in RECTANGLE_FS {
	vec3 position_eye;
	vec3 normal_eye;
	vec2 texcoord;
	vec4 color;
	vec4 border_color;
	float depth_offset;
	flat int side; // 0 is back facing and 1 is front facing
	vec2 splatcoord;
	vec2 percentual_splat_size;
	vec2 percentual_blend_width;
	vec2 percentual_rectangle_size;
	vec2 percentual_core_size;
} fi;

uniform float gamma = 2.2;
uniform float grid_strength = 60.0;
uniform float grid_scale = 1.0;
uniform float segment_width = 0.02;
uniform vec2 domain_extent;

out vec4 frag_color;

void gammaCorrection(vec4 color)
{
    frag_color.rgb = clamp(pow(frag_color.rgb, vec3(gamma)),0.0,0.9999999);
}

#if SHOW_GRAPH == 1
float sdf_segment( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h );
}
#endif

void finish_fragment(vec4 color)
{
	vec2 tex_pos = fi.splatcoord*domain_extent;// texture space extent transformation [-0.5*extent,+0.5*extend]
    color = vec4(vec3(0.5f), 1.0);

	color = test_color(color);

	float distance_to_camera = distance(vec3(0.0), fi.position_eye);

#if SHOW_GRID == 1
	const vec2 tex_pos_grid = tex_pos+(0.5/grid_strength);
	const float N = grid_strength*(1.0/grid_scale);
	const vec2 w = fwidth(tex_pos_grid);
	const vec2 a = (tex_pos_grid+0.5*w)*grid_scale;
	const vec2 b = (tex_pos_grid-0.5*w)*grid_scale;
	const vec2 i = (floor(a)+min(fract(a)*N, 1.0)-floor(b)-min(fract(b)*N, 1.0))/(N*w)*(1.0/grid_scale);
	//const vec2 i = step(fract(tex_pos_grid), vec2(1.0/N));
	const float grid = (1.0-i.x)*(1.0-i.y);
	color = mix(vec4(1.0), color, grid);
#endif

#if SHOW_GRAPH == 1
	float sdf = sdf_segment(tex_pos, vec2(0.0), vec2(1.0));
	float segment = 1.0 - smoothstep(segment_width, segment_width-fwidth(sdf), sdf);
	color = mix(vec4(1.0, 1.0, 0.0, 1.0), color, segment);
#endif

	//color.r = 1.0/distance_to_camera;
	frag_color = color;
	gammaCorrection(color);
}