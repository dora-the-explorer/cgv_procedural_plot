#version 450

#define SHOW_GRID 0
#define SHOW_GRAPH 0

/*
The following interface is implemented in this shader:
//***** begin interface of procedural_plot.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
//***** end interface of procedural_plot.glfs ***********************************
*/

//***** begin interface of hallo_world.glfs ***********************************
vec4 test_color(vec4 color);
//***** end interface of hallo_world.glfs ***********************************

in RECTANGLE_FS {
	vec3 position_eye;
	vec3 normal_eye;
	vec2 texcoord;
	vec4 color;
	vec4 border_color;
	float depth_offset;
	flat int side; // 0 is back facing and 1 is front facing
	vec2 splatcoord;
	vec2 percentual_splat_size;
	vec2 percentual_blend_width;
	vec2 percentual_rectangle_size;
	vec2 percentual_core_size;
} fi;

uniform float gamma = 2.2;
uniform float grid_strength = 60.0;
uniform float grid_scale = 1.0;
uniform float segment_width = 0.02;
uniform vec2 domain_extent;

out vec4 frag_color;

void gammaCorrection(vec4 color)
{
    frag_color.rgb = clamp(pow(frag_color.rgb, vec3(gamma)),0.0,0.9999999);
}

#if SHOW_GRAPH == 1
vec2[100] sample_sin()
{
	vec2 s[100];
	for(int i = 0; i<100; i++)
	{
		const float x = 0.02*i;
		const float y = sin(x*180.0*0.035);
		s[i] = vec2(x, y);
	}
	return s;
}
vec2[100] sample_cos()
{
	vec2 s[100];
	for(int i = 0; i<100; i++)
	{
		const float x = 0.02*i;
		const float y = cos(x*180.0*0.035);
		s[i] = vec2(x, y);
	}
	return s;
}
float sdf_segment(in vec2 p, in vec2 a, in vec2 b)
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h );
}
float draw_graph(in vec2 p, vec2[100] s)
{
	float sdf = 1.0;
	for(int i = 0; i<99; i++)
	{
		sdf = min(sdf, sdf_segment(p, s[i], s[i+1]));
	}
	float segment = 1.0 - smoothstep(segment_width, segment_width-fwidth(sdf), sdf);
	return segment;
}
#endif

void finish_fragment(vec4 color)
{
	vec2 tex_pos = fi.splatcoord*domain_extent;// texture space extent transformation [-0.5*extent,+0.5*extend]
    color = vec4(vec3(0.3f), 1.0);
	//const vec2 w = fwidthFine(tex_pos);

	color = test_color(color);

	float distance_to_camera = distance(vec3(0.0), fi.position_eye);

#if SHOW_GRID == 1
	const vec2 tex_pos_grid = tex_pos+(0.5/grid_strength);
	const float N = grid_strength*(1.0/grid_scale);
	const vec2 w = fwidth(tex_pos_grid);
	const vec2 a = (tex_pos_grid+0.5*w)*grid_scale;
	const vec2 b = (tex_pos_grid-0.5*w)*grid_scale;
	const vec2 i = (floor(a)+min(fract(a)*N, 1.0)-floor(b)-min(fract(b)*N, 1.0))/(N*w)*(1.0/grid_scale);
	//const vec2 i = step(fract(tex_pos_grid), vec2(1.0/N));
	const float grid = (1.0-i.x)*(1.0-i.y);
	color = mix(vec4(1.0), color, grid);
#endif

#if SHOW_GRAPH == 1
	/*float sdf = sdf_segment(tex_pos, vec2(0.0), vec2(1.0));
	float segment = 1.0 - smoothstep(segment_width, segment_width-fwidth(sdf), sdf);
	//float segment = 1.0 - smoothstep(segment_width, segment_width-w.x, sdf);
	color = mix(vec4(1.0, 1.0, 0.0, 1.0), color, segment);*/
	float segment = draw_graph(tex_pos, sample_sin());
	color = mix(vec4(1.0, 1.0, 0.0, 1.0), color, segment);
	segment = draw_graph(tex_pos, sample_cos());
	color = mix(vec4(1.0, 0.0, 1.0, 1.0), color, segment);
#endif

	//color.r = 1.0/distance_to_camera;
	frag_color = color;
	gammaCorrection(color);
}